use redox_ecc::weierstrass::{Scalar, Point};
use redox_ecc::instances::{P256, GetCurve};
use num_bigint::{BigInt, Sign, ToBigInt};
use sodiumoxide::randombytes::randombytes;
use redox_ecc::ellipticcurve::{EllipticCurve, Encode};
use h2c_rust_ref::{P256_XMDSHA256_SSWU_RO_, GetHashToCurve};
use std::convert::TryInto;

use sha3::Digest;
use hmac::{Hmac, Mac};

type H = sha3::Sha3_256;
type F = Hmac<sha3::Sha3_256>;

pub fn random_scalar(size: usize) -> Scalar {
    // Uses libsodium to generate cryptographic pseudo-random bytes using chacha20
    return bytes_to_scalar(&randombytes(size));
}

pub fn bytes_to_scalar(bytes: &[u8]) -> Scalar {
    return P256.get().new_scalar(BigInt::from_bytes_le(Sign::Plus, bytes));
}

pub fn gen_multiple(scalar: Scalar) -> Point {
    return P256.get().get_generator() * scalar;
}

// computes hash_over_curve of a message over the NIST P256 curve.
// cf : https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-06
pub fn h_prime(msg: &str) -> Point {
    let dst = b"P256_XMD:SHA-256_SSWU_RO_OPAQUE";
    let h = P256_XMDSHA256_SSWU_RO_.get(dst);
    let mut p = h.hash(msg.as_ref());
    p.normalize();
    return p;
}

pub fn is_valid(p: &Point) -> bool {
    let curve = P256.get();
    // first, check that alpha is in curve,
    // not the point to infinity,
    // and is generated by the generator
    let res =
        curve.is_on_curve(p) &&
            *p != curve.identity() &&
            p * curve.new_scalar(curve.get_order().to_bigint().unwrap() - 1) + p == curve.identity();
    return res;
}

pub fn hash_separated(data: &[&[u8]], separator: &[u8]) -> [u8; 32] {
    let mut hasher = H::new();
    for d in &data[..data.len() - 1] {
        hasher.input(d);
        hasher.input(separator);
    }
    hasher.input(data[data.len() - 1]);
    return hasher.result().try_into().unwrap();
}

pub fn hashmac_separated(data: &[&[u8]], separator: &[u8], key: &[u8]) -> [u8; 32] {
    let mut mac = F::new_varkey(key).unwrap();
    for d in &data[..data.len() - 1] {
        mac.input(d);
        mac.input(separator);
    }
    mac.input(data[data.len() - 1]);
    return mac.result().code().try_into().unwrap();
}


// change the boolean as the last param to do the key exchange as client or server
pub fn key_exchange(p: &Scalar, x: &Scalar, p_point: &Point, xu_point: &Point, xs_point: &Point, ssid_p: &[u8], s: &str, u: &str, server: bool) -> Result<[u8; 32], String> {
    if !is_valid(p_point) || !is_valid(xu_point) || !is_valid(xs_point) {
        return Err(String::from("one of the points is not valid"));
    }

    let eu = bytes_to_scalar(&hash_separated(&[&xu_point.encode(true), s.as_bytes(), &ssid_p], b"|"));
    let es = bytes_to_scalar(&hash_separated(&[&xs_point.encode(true), u.as_bytes(), &ssid_p], b"|"));

    return if server {
        let res = xu_point + p_point * eu;
        let res = res.clone() * x.clone() + res * (es * p.clone());
        Ok(hash_separated(&[&res.encode(true)], b""))
    } else {
        let res = xs_point + p_point * es;
        let res = res.clone() * x.clone() + res * (eu * p.clone());
        Ok(hash_separated(&[&res.encode(true)], b""))
    };
}